<template>
    <div v-if="component_key > 0">
      <div class="mef_container">
        <div class="mef-table no-compact">
          <div class="mef-table-divisor">
            <table id="mef-table-list-circuit" class="table mef-table-list-circuit">
              <thead>
                <tr>
                  <template v-for="(header, index) in data_headers">
                    <th scope="col" v-if="header == 'id'">#</th>
                    <th scope="col" class="header" @click="defineSort(index)" v-else>
                      {{ header }}
                      <span class="order-dir" v-if="currentSort === index">
                        {{ spanDir(index) }}
                      </span>
                    </th>
                  </template>
                </tr>
                <tr class="header-filter">
                  <template v-for="(header, index) in data_header_id">
                    <th scope="col" v-if="header == 'mef_dpid_id'"></th>
                    <th scope="col" v-else>
                      <input :id="header + '_search'" :id="'{header}_search'"
                        tooltip="DPID" @keyup="filterCircuitList"
                        v-if="!(['mef_lst_enabled', 'mef_lst_active'].includes(header))">
                      </input>
                    </th>
                  </template>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(row, rindex) in rowsOfPage"
                  v-bind:class="{ inactive: !row['Active'] }"
                  @click="rowClicked(row['id'])">
                  <th scope="row" style="width: 45px">{{ rindex + 1 }}</th>
                  <template v-for="(column, cindex) in row"> 
                    <td v-if="cindex != 'id'">
                      <template v-if="cindex == 'Enabled' || cindex == 'Active'">
                        <i class="material-icons" style="color:green" 
                          v-if="column">done</i>
                        <i class="material-icons" style="color:#c00000" 
                          v-else>close</i>
                      </template>
                      <template v-else>{{ column }}</template>
                    </td>
                  </template>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <div v-else>
      <div class="mef_container">
        <p class='empty-con-list' v-if="flag_loading">Loading EVCs. Please wait...</p>
        <p class='empty-con-list' v-else>No EVCs Installed.<br>
          Close this info-panel and try again, please.</p>
        </div>
    </div>
</template>

<script>
module.exports = {
  data(){
    return {
      flag_loading: false,
      component_key: 0,
      data_header_id:  ['mef_dpid_id', 'mef_lst_name', 
                      'mef_lst_sw_a', 'mef_lst_prt_a', 'mef_lst_int_a', 'mef_lst_tag_a',
                      'mef_lst_sw_z', 'mef_lst_prt_z', 'mef_lst_int_z', 'mef_lst_tag_z', 
                      'mef_lst_enabled',
                      'mef_lst_active'],                         
      data_headers: ['id', 'Name', 'Switch A', 'Port A', 'Interf. A', 'Tag A', 
                      'Switch Z', 'Port Z', 'Interf. Z', 'Tag Z',
                      'Enabled', 'Active'],
      data_rows: [],
      currentSort: 0,
      currentSortDir: [],
      dpid_names: {},  // DPIDs names
      interface_names: {} // DPIDs and interface data and metadata
    }
  },
  methods: {
    defineSort: function(newSort) {
      /**
      * Identify the direction of the sort for
      * the selected column as sort base
      */
      if(newSort === this.currentSort) {
        let sortDir = (this.currentSortDir[newSort] === 'asc') ? 'desc' : 'asc'
        this.$set(this.currentSortDir, newSort, sortDir);
        /**
        * It is necessary to use a different syntax to replace arrays values
        * by index because Vue cannot detect when directly set an item with
        * the index like it is usually done. In this case should've been:
        * this.currentSortDir[newSort] = sortDir;
        */
      }
      this.currentSort = newSort;
    },
    spanDir(index) {
      /**
      * Defines a span marker only for the selected
      * column to indicate its sort direction
      */
      if (this.currentSortDir[index] === 'desc')
        return '▾';
      return '▴';
    },
    rowClicked: function(id) {
      /**
      * Action triggered with a click in a list item
      */
      this.openCircuit(id);
    },
    openCircuit: function(id) {
      /**
      * Open the circuit detail in another panel.
      */
      var content = {
        "component": 'kytos-mef_eline-k-info-panel-show_circuit',
        "content": {'id':id},
        "icon": "gear",
        "title": "Circuit Details",
        "subtitle": "by kytos/mef_eline"
      }
      this.$kytos.$emit("showInfoPanel", content);
    },
    filterCircuitList: function(event) {
      /**
      * Filter circuit list.
      * It is triggered by keyup in every filter.
      */
      this.clearListFilter();

      // check data headers to filter
      // ignore the id column (x=1)
      for(let x = 0; x < this.data_header_id.length; x++) {
        let s_id = this.data_header_id[x] + "_search";
        
        let component = document.getElementById(s_id);
        if(!component)
          continue;

        let filter = component.value.toUpperCase();
        if(filter.length == 0)
          continue;

        // Declare variables
        let table, tr, td, txtValue;
        let index = x;

        table = document.getElementById("mef-table-list-circuit");
        // hide table to prepare to render the cells
        table.style.display = "none";
        body = table.getElementsByTagName("tbody");
        tr = body[0].getElementsByTagName("tr");

        // Loop through all table rows, and hide those who don't match the search query
        for (let i = 0; i < tr.length; i++) {
          // first cell in tbody is a th tag, not a td tag
          td = tr[i].getElementsByTagName("td")[index-1];
          
          if (td) {
            txtValue = td.textContent || td.innerText;
            if (txtValue.toUpperCase().indexOf(filter) < 0)
              tr[i].style.display = "none";
          }
        }
        // show table
        table.style.display = "";
      }
    },
    clearListFilter: function() {
      /**
      * Clear circuit list column filters.
      */
      let table = document.getElementById("mef-table-list-circuit");
      let body = table.getElementsByTagName("tbody")[0];
      let tr = body.getElementsByTagName("tr");
      for (let i = 0; i < tr.length; i++) {
        tr[i].style.display = "";
      }
    },
    forceRerender: function() {
      /**
       * Force Vue to re-render the view.
       */
      this.component_key += 1;
    },
    listEVCs: function() {
      /**
       * Call mef_eline REST endpoint to load EVC list.
       */
      this.flag_loading = true;
      this.component_key = 0;
      var tableRows = [];
      var _this = this;

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/mef_eline/v2/evc/",
        type:"GET",
        data: JSON.stringify(),
        dataType: "json",
        contentType: "application/json; charset=utf-8"
      });
      request.done(function(data) {
        $.each(data, function(i , evc) {
          if (evc) {
            let endpoint_a =  (evc.uni_a) ? evc.uni_a.interface_id : "";
            let endpoint_data_a = _this.getEndpointData(endpoint_a);
            let tag_a = (evc.uni_a && evc.uni_a.tag) ? evc.uni_a.tag.value : "";

            let endpoint_z =  (evc.uni_z) ? evc.uni_z.interface_id : "";
            let endpoint_data_z = _this.getEndpointData(endpoint_z);
            let tag_z = (evc.uni_z && evc.uni_z.tag) ? evc.uni_z.tag.value : "";  
            
            let connection = {
              "id": evc.id,
              "Name": evc.name,
              "Switch A": endpoint_data_a.node_name,
              "Port A": endpoint_data_a.port,
              "Interf. A": endpoint_data_a.interface_name,
              "Tag A": tag_a,
              "Switch Z": endpoint_data_z.node_name,
              "Port Z": endpoint_data_z.port,
              "Interf. Z": endpoint_data_z.interface_name,
              "Tag Z": tag_z,
              "Enabled": evc.enabled,
              "Active": evc.active
            };
            tableRows.push(connection);
          }
        });

        _this.data_rows = tableRows;
        _this.forceRerender(); 
        _this.flag_loading = false;
      });

      request.fail(function( jqXHR, textStatus ) {
        alert( "Request failed: " + textStatus );
        _this.flag_loading = false;
      });
      
      return tableRows;
    },
    loadDpidNames: function() {
      /**
      * Call REST endpoint with switch and interface attributes and metadata.
      */
      let _dpid_names = {};
      let _interface_names = {};
      var _this = this;

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/topology/v3/switches",
        type:"GET",
        data: JSON.stringify(),
        dataType: "json",
        contentType: "application/json; charset=utf-8"
      });
      request.done(function(data) {
        let switches = data.switches;
        $.each(switches, function(i , sw) {
          if(sw.metadata.node_name) {
            _dpid_names[sw.dpid] = sw.metadata.node_name;
          }
          if(sw.interfaces) {
            $.each(sw.interfaces, function(j , interface) {
              _interface_names[interface.id] = interface.name;
            });
          }
        });
        _this.dpid_names = _dpid_names;
        _this.interface_names = _interface_names;
      });
      request.fail(function( jqXHR, textStatus ) {
        alert( "Request failed: " + textStatus );
      });
    },
    getEndpointData: function(endpoint) {
      /**
      * Get DPID and Interface attributes and metadata.
      * Parameter: <switch>:<port>
      */
      let dpid = endpoint.substring(0, 23);
      let port = endpoint.substring(24);
      let interface_name = (endpoint in this.interface_names) ? this.interface_names[endpoint] : port;
      let node_name = (dpid in this.dpid_names) ? this.dpid_names[dpid] : dpid
      return {
        "dpid": dpid,
        "node_name": node_name,
        "port": port,
        "interface_name": interface_name
      };
    }
  },
  computed: {
    rowsOfPage: function() {
      /**
       * Orders by ascendant or descendant of a
       * selected column
       */
      return this.data_rows.sort((a, b) => {
        let modifier = 1,
            key_a = Object.keys(a),
            key_b = Object.keys(b);
        if(this.currentSortDir[this.currentSort] === 'desc')
          modifier = -1;
        if(a[key_a[this.currentSort]] < b[key_b[this.currentSort]])
          return -1 * modifier;
        if(a[key_a[this.currentSort]] > b[key_b[this.currentSort]])
          return modifier;
        return 0;
      });
    },
  },
  mounted() {
      // Load DPID attributes and metadata
    this.loadDpidNames();
      // Load EVCs
    this.listEVCs();
    // Make the panel fill the screen except the left menu width
    $('.k-info-panel:has(.mef_container)').addClass('mef-k-info-panel');

    // Initialize list sort direction
    this.currentSortDir = Array(this.data_headers.length).fill('asc');
  },
  destroyed() {
    $('.k-info-panel').removeClass('mef-k-info-panel');
  }
}
</script>

<style>
/* Import icons */
@import "https://fonts.googleapis.com/icon?family=Material+Icons";

.mef-k-info-panel {
  width: calc(100% - 300px);
}

.mef_container .empty-con-list {
  margin-top: 10px;
  color: #ccc;
  font-size: 0.8rem;
}

.mef-table {
  color: #ccc;
  max-height: 250px;
  text-align: center;
  margin: 0 auto;
  display: block;
  padding: 0.5em 0 1em 0.3em;
  font-size: .8em;
  height: 190px;
}
.mef-table table {
  display: table;
  width: 100%;
}
.mef-table thead {
  font-weight: bold;
  background: #554077;
}
.mef-table th {
  padding: 0.6em 0 0.6em  0;
}
.mef-table tr {
  color: lightgray;
}
.mef-table td {
  vertical-align: middle;
}
.mef-table .header {
  cursor: pointer;
}
.mef-table .header-filter th {
  padding: 0 0 0.5em 0;
  background: #554077;
}
.mef-table .header-filter input {
  background: lightgray;
  border: 1px solid gray;
  border-radius: 3px;
  font-size: 0.9em;
  margin: 0 0.2em 0 0.2em;
}
.mef-table tbody tr:nth-child(even) {
  background: #313131;
}
.mef-table tbody tr:hover {
    color: #eee;
    background-color: #666;
}
.mef-table tbody tr.inactive {
  background-color: #600000;
}
.mef-table-divisor {
  height: 190px;
}
#mef_lst_prt_a_search,
#mef_lst_prt_z_search,
#mef_lst_tag_a_search,
#mef_lst_tag_z_search {
  width: 4em;
}

.mef_container .order-dir {
  display: inline-block;
  width: 12px;
}
</style>
