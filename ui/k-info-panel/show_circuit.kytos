<template>
    <div class="mef_circuit_container">
      <div class="mef-buttons">
        <div class="mef-buttons-left">
          <div class="mef-back-button">
            <k-button tooltip="List installed EVCs" title="< Back to list" :on_click="showInfoPanel">
            </k-button>
          </div>
        </div>
        <div class="mef-buttons-right">
          <div class="mef-save-button">
            <k-button tooltip="Save EVC" title="Save EVC" :on_click="saveEvc">
            </k-button>
          </div>
          <div class="mef-delete-button">
            <k-button tooltip="Delete EVC" title="Delete EVC" :on_click="showModalDeleteEvc">
            </k-button>
          </div>
        </div>
      </div>
      <div class="mef-table no-compact">
        <div class="mef-circuit-table">
         <table class="table">
            <template v-for="(column, cindex) in basics"> 
              <tr>
                <th>{{cindex}}</th>
                <td>
                  <k-input v-if="column.editable" :id="column.name" :value.sync="column.value"></k-input>
                  <span v-else>
                    {{column.value}}
                  </span>
                </td>
              </tr>
            </template>
          </table>
        </div>
        <div class="mef-circuit-table" id="mef-flags">
         <table class="table">
            <template v-for="(column, cindex) in flags"> 
              <tr><th>{{cindex}}</th>
              <td>
                <template v-if="column.editable">
                  <div class="k-button-wrapper compact" @click="column.value = column.value?false:true;">
                    <button :title="column.value" class="k-button compact">
                      <i class="material-icons check_true" v-if="column.value">done</i>
                      <i class="material-icons check_false" v-else>close</i>
                    </button>
                  </div>
                </template>
                <template v-else>
                  <i class="material-icons check_true" v-if="column.value">done</i>
                  <i class="material-icons check_false" v-else>close</i>
                </template>
              </td></tr>
            </template>
          </table>
        </div>
        <div class="mef-circuit-table">
         <table class="table">
            <template v-for="(column, cindex) in others"> 
              <tr>
                <th>{{cindex}}</th>
                <td>
                  <k-input v-if="column.editable" :id="column.name" :value.sync="column.value"></k-input>
                  <span v-else>
                    {{column.value}}
                  </span>
                </td>
              </tr>
            </template>
          </table>
        </div>
        <div class="mef-circuit-table">
         <table class="table">
            <template v-for="(column, cindex) in dates"> 
              <tr><th>{{cindex}}</th><td>{{column}}</td></tr>
            </template>
          </table>
        </div>

        <div class="mef-circuit-table" id="mef-unis">
         <table class="table">
            <tbody>
              <tr>
                <th></th>
                <th>UNI A</th>
                <th>UNI Z</th>
              </tr>
              <template v-for="(data, cindex) in endpoints_data">
                <tr>
                  <th>{{cindex}}</th>
                  <template v-for="col in data">
                    <td>
                      <k-input-auto
                        :value.sync="col.value"
                        title="col.name"
                        :candidates="dpids"
                        @focus="loadDpidNames"
                        @blur="onblur_dpid"
                        v-if="compexists && (col.name=='uni_a' || col.name=='uni_z')">
                      </k-input-auto>
                      <template v-else>
                        <k-input v-if="col.editable" :id="col.name" :value.sync="col.value"></k-input>
                        <span v-else>
                          {{col.value}}
                        </span>
                      </template>
                    </td>
                  </template>
                </tr>
              </template>
            </tbody>
          </table>
        </div>

        <template v-for="(path, pindex) in paths">
          <div class="mef-circuit-table mef-circuit-table-path">
            <table class="table">
              <tbody>
                <tr>
                  <th>{{pindex}}</th>
                  <td v-if="path && path.length > 0">
                    <template v-for="step in path">
                      <table class="mef-path-table">
                        <tr>
                          <th></th><th>Endpoint A</th><th>Endpoint B</th>
                        </tr>
                        <template v-for="(attr, cindex) in step">
                          <tr>
                            <th>{{cindex}}</th><td>{{attr[0]}}</td><td>{{attr[1]}}</td>
                          </tr>
                        </template>
                      </table>
                    </template>
                </td>
                </tr>
              </tbody>
            </table>
          </div>
        </template>
      </div>
      <div class="mef-back-button">
        <k-button tooltip="List installed EVCs" title="< Back to list" :on_click="showInfoPanel">
        </k-button>
      </div>
      <template v-if="showDelModal">
        <div class="modal-mask">
          <div class="modal-wrapper">
            <div class="modal-container">
              <div class="modal-header">
                <slot name="header">
                </slot>
              </div>
              <div class="modal-body">
                <slot name="body">
                  Delete EVC? 
                </slot>
              </div>
              <div class="modal-footer">
                <slot name="footer">
                  <k-button tooltip="Cancel" title="Cancel" :on_click="modalClose">
                  </k-button>
                  <k-button id="modalOK" tooltip="Delete" title="Delete" :on_click="modalOK">
                  </k-button>
                </slot>
              </div>
            </div>
          </div>
        </div>
      </template>
    </div>
    
</template>
<script>
module.exports = {
  props: {
    content: {
      type: Object,
      required: true,
    },
  },
  data(){
    return {
        component_key: 0,
        circuit: {},  // EVC data
        dpids: [],  // DPIDs - used for autocomplete
        dpid_names: {},  // DPIDs names
        interface_data: {},  // DPIDs and interface data and metadata
        endpoints_data: {}, // EVC endpoints data
        basics: {}, // EVC basic data
        flags: {}, // EVC flags data
        others: {}, // EVC others data
        dates: {}, // EVC dates
        paths: {}, // EVC paths data
        links: {}, // EVC links data
        circuit_scheduler: {}, // EVC scheduler data
        showDelModal: false,
        TAG_TYPE_VLAN: 1, // Tag type VLAN
    }
  },
  methods: {
    showInfoPanel: function() {
      let listConnections = {
          component: 'kytos-mef_eline-k-info-panel-list_connections',
          content: {},
          icon: "desktop",
          title: "View Connections",
          subtitle: "by kytos/mef_eline"
      }
      this.$kytos.$emit("showInfoPanel", listConnections);
    },
    showModalDeleteEvc: function() {
      /**
       * Show modal window do delete circuit.
       */
      this.showDelModal = true;
    },
    modalClose: function() {
      /**
       * Modal window - Close (X) buttom
       */
      this.showDelModal = false;
    },
    modalOK: function() {
      /**
       * Modal window - OK buttom
       */
      this.showDelModal = false;
      this.deleteEVC();
    },
    forceRerender: function() {
      /**
       * Force Vue to re-render the view.
       */
      this.component_key += 1;
    },
    loadEVC: function(id) {
      /**
       * Call mef_eline REST endpoint to load EVC data.
       */
      this.component_key = 0;
      var _this = this;

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/mef_eline/v2/evc/" + id,
        type:"GET",
        data: JSON.stringify(),
        dataType: "json",
        contentType: "application/json; charset=utf-8"
      });
      
      request.done(function(data) {
        _this.buidEvcView(data);
        _this.forceRerender();
      });
      request.fail(function( jqXHR, textStatus ) {
        let notification = {
            title: 'Error loading EVC.',
            description: "Request failed: " + textStatus
        }
        _this.$kytos.$emit("setNotification" , notification);
      });
    },
    deleteEVC: function() {
      /**
       * Call mef_eline REST endpoint to delete EVC data.
       */
      var id = this.circuit['id'];
      var _this = this;

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/mef_eline/v2/evc/" + id,
        type:"DELETE"
      });
      request.done(function(data) {
        // Go back
        _this.showInfoPanel();
      });
      request.fail(function( jqXHR, textStatus ) {
        let notification = {
            title: 'Error deleting EVC.',
            description: "Request failed: " + textStatus
        }
        _this.$kytos.$emit("setNotification" , notification);
      });
    },
    onblur_dpid: function() {
      /**
       * Update dpid values on event onblur triggered in dpids fields.
       * It split the value selected from autocomplete list.
       * It is expected the value as "NAME - DPID".
       **/
      let dpid_a = this.endpoints_data["DPID"][0]["value"];
      if(dpid_a.lastIndexOf(' ') > 0) {
        let splitted_dpid = dpid_a.split(' ');
        this.endpoints_data["Interface"][0]["value"] = splitted_dpid[0];
        this.endpoints_data["DPID"][0]["value"] = splitted_dpid[2];
      }
      
      let dpid_z = this.endpoints_data["DPID"][1]["value"];
      if(dpid_z.lastIndexOf(' ') > 0) {
        let splitted_dpid = dpid_z.split(' ');
        this.endpoints_data["Interface"][1]["value"] = splitted_dpid[0];
        this.endpoints_data["DPID"][1]["value"] = splitted_dpid[2];
      }
    },
    buidEvcView: function(data) {
      /**
      * Build new EVC object for exibition.
      * Parameter: 
      *   data: evc json from mef_eline
      */
      this.circuit = data;

      let uni_a = this.circuit['uni_a']['interface_id'];
      let uni_a_data = this.getEndpointData(uni_a);
      let uni_z = this.circuit['uni_z']['interface_id'];
      let uni_z_data = this.getEndpointData(uni_z);

      this.endpoints_data = {
        'DPID': [
         {'value': uni_a, 'editable':true, 'name':'uni_a'}, 
         {'value': uni_z, 'editable':true, 'name':'uni_z'}],
        'Node': [ 
         {'value': uni_a_data['node_name']}, 
         {'value': uni_z_data['node_name']}],
        'Interface': [ 
         {'value': uni_a_data['interface_name']}, 
         {'value': uni_z_data['interface_name']}],
        'Port':[ 
         {'value': uni_a_data['port_name']}, 
         {'value': uni_z_data['port_name']}]
      };

      // Tag is optional, but can be edited
      let tag_a = {'value': this.circuit['uni_a']['tag'] ? this.circuit['uni_a']['tag']['value'] : "", 
                   'editable':true, 
                   'name':'tag_a'};
      let tag_z = {'value': this.circuit['uni_z']['tag'] ? this.circuit['uni_z']['tag']['value'] : "", 
                   'editable':true, 
                  'name':'tag_z'};
      this.endpoints_data['Tag Value'] = [tag_a, tag_z];

      this.basics = {'ID': {'value': data['id'], 'editable':false},
                     'Name': {'value': data['name'], 'editable':true, 'name':'name'}
                    };
      this.flags = {'Enabled': {'value': data['enabled']?true:false, 'editable':true},
                    'Active': {'value': data['active']?true:false, 'editable':false},
                    'Archived': {'value': data['archived']?true:false, 'editable':false},
                    'Dynamic backup path': {'value': data['dynamic_backup_path']?true:false, 'editable':true}
                   };
      this.others = {'Owner': {'value': data['owner']},
                     'Priority': {'value': data['priority'], 'editable':true, 'name':'priority'},
                     'Bandwidth': {'value': data['bandwidth'], 'editable':true, 'name':'bandwidth'},
                     'Queue': {'value': data['queue_id'], 'editable':true, 'name':'queue_id'}
                    };
      this.dates = {'Request time': data['request_time'],
                    'Creation time': data['creation_time'],
                    'Start date': data['start_date'],
                    'End date': data['end_date']
                   };
      this.paths = {"Current path": this.buildPathView(data['current_path']),
                    "Primary path": this.buildPathView(data['primary_path']),
                    "Backup path": this.buildPathView(data['backup_path'])
                   };

      this.links = {"Primary links": data['primary_links'],
                      "Backup links": data['backup_links']
                   };
      
      this.circuit_scheduler = data['circuit_scheduler'];
    },
    buildPathView: function(path_data) {
      /**
      * Build path data for exibition. (current, primary and backup paths)
      * Parameter:
      *   path_data: json with path data
      */
      let _path = [];
      if(path_data) {
        for(key_path in path_data) {
          let path_step = path_data[key_path];

          let svlan = ('metadata' in path_step && 's_vlan' in path_step['metadata']) ?
                       path_step['metadata']['s_vlan']['value'] : "";

          let dpid_a = path_step['endpoint_a']['id'];
          let data_a = this.getEndpointData(dpid_a);

          let dpid_b = path_step['endpoint_b']['id'];
          data_b = this.getEndpointData(dpid_b);

          let _item = {
            'DPID': [dpid_a, dpid_b],
            'Node': [data_a['node_name'], data_b['node_name']],
            'Interface': [data_a['interface_name'], data_b['interface_name']],
            'Port': [data_a['port_name'], data_b['port_name']],
            'Link': [data_a['link_name'], data_b['link_name']],
            'S-VLAN': [svlan, svlan]
          };
          _path.push(_item);
        }
      }
      return _path;
    },
    loadDpidNames: function() {
      /**
      * Call REST endpoint with switch and interface attributes and metadata.
      */
      let _dpid_names = {};
      let _interface_data = {};
      var _this = this;

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/topology/v3/switches",
        type:"GET",
        data: JSON.stringify(),
        dataType: "json",
        contentType: "application/json; charset=utf-8"
      });
      request.done(function(data) {
        let switches = data.switches;
        $.each(switches, function(i , sw) {
          if(sw.metadata.node_name) {
            _dpid_names[sw.dpid] = sw.metadata.node_name;
          }
          if(sw.interfaces) {
            $.each(sw.interfaces, function(j , interface) {
              // store interface name data 
              let metadata = interface.metadata;
              _interface_data[interface.id] = {
                "name": interface.name,
                "link_name": (metadata && "link_name" in metadata) ? interface.metadata.link_name : "",
                "port_name": (metadata && "port_name" in metadata) ? interface.metadata.port_name : ""
              };

              // store autocomplete dpids
              let value = interface.id;
              if(interface.name) {
                value = interface.name + " - " + value;
              }
              if(!_this.dpids.includes(value)) {
                _this.dpids.push(value);
              }
            });
          }
        });
        _this.dpids.sort();
        _this.dpid_names = _dpid_names;
        _this.interface_data = _interface_data;
      });
      request.fail(function( jqXHR, textStatus ) {
        let notification = {
          title: 'Error loading EVC names.',
          description: "Request failed: " + textStatus
        }
        _this.$kytos.$emit("setNotification" , notification);
      });
    },
    getEndpointData: function(endpoint) {
      /**
      * Get DPID and Interface attributes and metadata.
      * Parameter: <switch>:<port>
      */
      let dpid = endpoint.substring(0, 23);
      let port = endpoint.substring(24);
      let node_name = (dpid in this.dpid_names) ? this.dpid_names[dpid] : dpid;

      let interface_name =  port;
      let link_name = "";
      let port_name = "";
      if(endpoint in this.interface_data) {
        let _data = this.interface_data[endpoint];
        interface_name = _data["name"];
        link_name = ("link_name" in _data) ? _data["link_name"] : "";
        port_name = ("port_name" in _data) ? _data["port_name"] : "";
      }
      
      let result = {
        "dpid": dpid,
        "node_name": node_name,
        "port": port,
        "interface_name": interface_name,
        "link_name": link_name,
        "port_name": port_name
      };

      return result;
    },
    saveEvc: function() {
      /**
      * Build a payload and save.
      */
      var _this = this;
      let id = this.basics["ID"]["value"];

      let payload = {
        name: this.basics["Name"]["value"],
        enable: this.flags["Enabled"]["value"],
        dynamic_backup_path: this.flags["Dynamic backup path"]["value"],                
        priority: parseInt(this.others["Priority"]["value"]),
        bandwidth: this.others["Bandwidth"]["value"],
        queue_id: this.others["Queue"]["value"],
        uni_a: {
          interface_id: this.endpoints_data["DPID"][0]["value"],
        },
        uni_z: {
          interface_id: this.endpoints_data["DPID"][1]["value"],
        },
      };

      // Tag is optional
      if(this.endpoints_data["Tag Value"][0]["value"]) {
        payload["uni_a"]["tag"] = {
          tag_type: this.TAG_TYPE_VLAN,
          value: parseInt(this.endpoints_data["Tag Value"][0]["value"])
        };
      }
      if(this.endpoints_data["Tag Value"][1]["value"]) {
        payload["uni_z"]["tag"] = {
          tag_type: this.TAG_TYPE_VLAN,
          value: parseInt(this.endpoints_data["Tag Value"][1]["value"])
        };
      }

      var request = $.ajax({
        url: this.$kytos_server_api + "kytos/mef_eline/v2/evc/" + id,
        type:"PATCH",
        data: JSON.stringify(payload),
        contentType: "application/json; charset=utf-8"
      });
      request.done(function(data) {
        let notification = {
          title: 'EVC ' + id + ' updated.',
          description: ''
        }
        _this.$kytos.$emit("setNotification" , notification);
        _this.loadEVC(_this.content.id);
      });
      request.fail(function( jqXHR, textStatus ) {
        let notification = {
          title: 'Update EVC failed',
          description: 'Error updating EVC ' + id +'. ' + textStatus
        }
        _this.$kytos.$emit("setNotification" , notification);
      });
    },
  },
  mounted() {
    if(this.content && this.content.id) {
      // Load DPID attributes and metadata
      this.loadDpidNames();
      // Load EVC
      this.loadEVC(this.content.id);
      // Make the panel fill the screen except the left menu width
      $('.k-info-panel:has(.mef_circuit_container)').addClass('mef-k-info-panel');
      
      this.$kytos.dpids = this.dpids;
    }
  },
  created() {
    // Check if the UI component k-input-auto exists
    compexists = this.$root.$options.components['k-input-auto'] != null;
  },
  destroyed() {
    $('.k-info-panel').removeClass('mef-k-info-panel');
  }
}
</script>
<style>
  /* Import icons */
  @import "https://fonts.googleapis.com/icon?family=Material+Icons";
  
  .mef-k-info-panel {
    width: calc(100% - 300px);
  }
  .empty-con-list {
    margin-top: 10px;
    color: #ccc;
    font-size: 0.8rem;
  }
  .mef_circuit_container .check_true {
    color: green;
  }
  .mef_circuit_container .check_false {
    color: #c00000;
  }
  .mef_circuit_container .mef-buttons {
    display: flow-root;
  }
  .mef-buttons .mef-buttons-left {
    float: left;
  }
  .mef-buttons .mef-buttons-right {
    float: right;
    display: flex;
  }
  .mef-buttons .mef-delete-button button {
    background: darkred;
  }
  .mef_circuit_container input {
    text-align: center;
    font-size: 1em;
  }
  .mef_circuit_container input:focus {
    border: 1px solid blueviolet;
  }
  .mef_circuit_container input:hover {
    background: #515151;
  }
  .mef_circuit_container #k-input-wrap:hover {
    background: #515151;
  }
  .mef_circuit_container .k-button-wrapper {
    display: flex;
    justify-content: center;
    float: none;
  }
  .mef_circuit_container tbody tr:hover {
    background: inherit;
  }
  .mef_circuit_container table {
    border-collapse: collapse;
    width: 100%;
    font-size: 0.9em;
  }
  .mef_circuit_container tr:nth-child(even) {
      background-color: #2d2d2d;
  }
  .mef_circuit_container td {
      border-left: 1px solid darkgray;
      padding: 5px;
  }
  .mef_circuit_container th {
    background-color: #372C5E;
    color: white;
    padding-top: 8px;
    padding-bottom: 8px;
    text-align: left;
  }
  .mef-circuit-table {
      width: 250px;
      float: left;
      margin-left: 20px;
      margin-bottom: 20px;
  }
  .mef-circuit-table th {
    width: 75px;
  }
  .mef-path-table th {
    width: 50px;
  }
  .mef-circuit-table table + table {
    margin-top:4px;
  }
  .mef-back-button {
    clear: both;
  }
  #mef-flags {
    clear:both;
  }
  #mef-flags th {
    width: 125px;
  }
  #mef-flags i {
    /* icon size */
    font-size: 1.1em;
  }
  #mef-unis {
    clear:both;
    width:520px;
  }
  .mef-circuit-table-path {
    clear:both; 
    width:520px;
  }
  /* Modal windows */
  .modal-mask {
    position: fixed;
    z-index: 9998;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: table;
    transition: opacity 0.3s ease;
  }
  .modal-wrapper {
    display: table-cell;
    vertical-align: middle;
  }
  .modal-container {
    width: 300px;
    margin: 0px auto;
    padding: 10px 10px 10px 20px;;
    background-color: #e8e8e8;
    border-radius: 2px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.33);
    transition: all 0.3s ease;
    font-family: Helvetica, Arial, sans-serif;
  }
  .modal-body {
    margin: 20px 0;
  }
  .modal-default-button {
    float: right;
  }
  .modal-enter {
    opacity: 0;
  }
  .modal-leave-active {
    opacity: 0;
  }
  .modal-enter .modal-container,
  .modal-leave-active .modal-container {
    -webkit-transform: scale(1.1);
    transform: scale(1.1);
  }
  .modal-footer {
    justify-content: end; 
    display: flex;
  }
  #modalOK {
    color: #ffc5c5;
    background: #be0000;
  }
  .autocomplete-result-list {
    width: 110% !important;
  }
  .autocomplete-result-list li {
    white-space: nowrap;
  }
</style>
